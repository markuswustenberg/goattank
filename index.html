<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goat Fish Tank</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a2e;
        }
        #tank {
            display: block;
            background: linear-gradient(to bottom, #0a4d68 0%, #1a6f8f 50%, #0a4d68 100%);
        }
        #commentary {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #222;
            padding: 12px 18px;
            border-radius: 15px;
            max-width: 300px;
            text-align: left;
            font-family: Arial, sans-serif;
            font-size: 15px;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s, left 0.1s ease-out, top 0.1s ease-out;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 0, 0, 0.1);
            transform: scale(0.8);
        }
        #commentary.visible {
            opacity: 1;
            transform: scale(1);
        }
        /* Pointer pointing down (bubble above fish) - default */
        #commentary::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid rgba(255, 255, 255, 0.95);
        }
        /* Pointer pointing up (bubble below fish) */
        #commentary.pointer-up::after {
            bottom: auto;
            top: -10px;
            border-top: none;
            border-bottom: 10px solid rgba(255, 255, 255, 0.95);
        }
        #menuButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #222;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            font-family: Arial, sans-serif;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: none;
            line-height: 1;
        }
        #menuButton:active {
            background: rgba(255, 255, 255, 0.7);
            transform: scale(0.95);
        }
        #menuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #menuOverlay.visible {
            display: flex;
        }
        #menuContent {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        #menuContent h2 {
            margin: 0 0 20px 0;
            font-family: Arial, sans-serif;
            font-size: 24px;
            color: #222;
        }
        .menuItem {
            background: rgba(26, 79, 104, 0.1);
            border: 2px solid rgba(26, 79, 104, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #222;
            display: block;
            width: 100%;
            text-align: left;
        }
        .menuItem:active {
            background: rgba(26, 79, 104, 0.2);
            transform: scale(0.98);
        }
        .menuItem strong {
            display: block;
            font-size: 18px;
            margin-bottom: 4px;
        }
        .menuItem small {
            color: #666;
            font-size: 14px;
        }
        #closeMenu {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 14px;
            margin-top: 8px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            width: 100%;
        }
        #closeMenu:active {
            background: #c0392b;
        }
        @media (max-width: 768px) {
            #menuButton {
                display: block;
            }
        }
    </style>
</head>
<body>
    <canvas id="tank"></canvas>
    <div id="commentary"></div>
    <button id="menuButton">‚ò∞</button>

    <div id="menuOverlay">
        <div id="menuContent">
            <h2>Goat Fish Tank Menu</h2>
            <button class="menuItem" id="menuScareAll">
                <strong>üêê Scare All Fish</strong>
                <small>Watch them all scatter!</small>
            </button>
            <button class="menuItem" id="menuFullscreen">
                <strong>‚õ∂ Toggle Fullscreen</strong>
                <small>Enter or exit fullscreen mode</small>
            </button>
            <button class="menuItem" id="menuCommentary">
                <strong>üí¨ Trigger Commentary</strong>
                <small>Get AI fish commentary (requires API key)</small>
            </button>
            <button class="menuItem" id="menuApiKey">
                <strong>üîë Set API Key</strong>
                <small>Configure Anthropic API key for AI commentary</small>
            </button>
            <button class="menuItem" id="menuReset">
                <strong>‚Üª Reset Tank</strong>
                <small>Clear saved state and start fresh</small>
            </button>
            <button id="closeMenu">Close Menu</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('tank');
        const ctx = canvas.getContext('2d');
        const commentaryDiv = document.getElementById('commentary');

        // AI Commentary System
        let lastCommentaryTime = 0;
        const COMMENTARY_INTERVAL = 45000; // 45 seconds between commentaries
        let speakingFish = null; // Track which fish is currently "speaking"
        let commentaryTimeout = null; // Track the timeout to clear it

        // Function to get API key from localStorage
        function getApiKey() {
            try {
                return localStorage.getItem('anthropicApiKey');
            } catch (e) {
                return null;
            }
        }

        // Function to save API key to localStorage
        function saveApiKey(key) {
            try {
                localStorage.setItem('anthropicApiKey', key);
                return true;
            } catch (e) {
                console.error('Failed to save API key:', e);
                return false;
            }
        }

        // Gather aquarium state for AI context
        function gatherAquariumState() {
            // Calculate social dynamics - count nearby fish for each
            goatFish.forEach(fish => {
                fish.nearbyFishCount = 0;
                goatFish.forEach(other => {
                    if (fish !== other) {
                        const dx = fish.x - other.x;
                        const dy = fish.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 150) { // Within 150px = "nearby"
                            fish.nearbyFishCount++;
                        }
                    }
                });
            });

            // Calculate aggregated statistics
            const totalSpooks = goatFish.reduce((sum, f) => sum + f.totalSpooked, 0);
            const totalDistance = goatFish.reduce((sum, f) => sum + f.distanceTraveled, 0);
            const personalities = goatFish.reduce((acc, f) => {
                acc[f.personality] = (acc[f.personality] || 0) + 1;
                return acc;
            }, {});

            // Count fish in different zones
            const upperZone = goatFish.filter(f => f.y < canvas.height * 0.33).length;
            const middleZone = goatFish.filter(f => f.y >= canvas.height * 0.33 && f.y < canvas.height * 0.67).length;
            const lowerZone = goatFish.filter(f => f.y >= canvas.height * 0.67).length;

            // Find fish with interesting states
            const mostSpooked = goatFish.reduce((max, f) => f.totalSpooked > max.totalSpooked ? f : max, goatFish[0]);
            const mostActive = goatFish.reduce((max, f) => f.distanceTraveled > max.distanceTraveled ? f : max, goatFish[0]);
            const mostLazy = goatFish.reduce((min, f) => f.distanceTraveled < min.distanceTraveled ? f : min, goatFish[0]);
            const mostSocial = goatFish.reduce((max, f) => f.nearbyFishCount > max.nearbyFishCount ? f : max, goatFish[0]);
            const mostLonely = goatFish.reduce((min, f) => f.nearbyFishCount < min.nearbyFishCount ? f : min, goatFish[0]);

            const state = {
                goatFishCount: goatFish.length,
                sheatfishCount: sheatfish.length,
                bubbleCount: bubbles.length,
                plantCount: plants.length,
                grassCount: grass.length,
                tankWidth: canvas.width,
                tankHeight: canvas.height,

                // Aggregate stats
                totalSpooksAllTime: totalSpooks,
                totalDistanceTraveled: Math.round(totalDistance),
                personalityDistribution: personalities,

                // Zone distribution
                fishInUpperZone: upperZone,
                fishInMiddleZone: middleZone,
                fishInLowerZone: lowerZone,

                // Interesting individual fish (hidden personalities!)
                mostSpookedFish: {
                    personality: mostSpooked.personality,
                    totalSpooked: mostSpooked.totalSpooked,
                    timeSinceLastSpook: mostSpooked.timeSinceLastSpook
                },
                mostActiveFish: {
                    personality: mostActive.personality,
                    distanceTraveled: Math.round(mostActive.distanceTraveled)
                },
                laziestFish: {
                    personality: mostLazy.personality,
                    distanceTraveled: Math.round(mostLazy.distanceTraveled)
                },
                mostSocialFish: {
                    personality: mostSocial.personality,
                    nearbyFriends: mostSocial.nearbyFishCount,
                    socialPreference: Math.round(mostSocial.socialPreference * 100)
                },
                loneliestFish: {
                    personality: mostLonely.personality,
                    nearbyFriends: mostLonely.nearbyFishCount,
                    socialPreference: Math.round(mostLonely.socialPreference * 100)
                },

                // Sample of individual fish states
                goatFishStates: goatFish.slice(0, 3).map(fish => ({
                    spooked: fish.spooked,
                    personality: fish.personality,
                    distanceTraveled: Math.round(fish.distanceTraveled),
                    nearbyFriends: fish.nearbyFishCount,
                    depth: Math.round((fish.y / canvas.height) * 100) + '%',
                    totalSpooked: fish.totalSpooked
                })),

                sheatfishPositions: sheatfish.map(fish => ({
                    x: Math.round(fish.x),
                    y: Math.round(fish.y)
                }))
            };
            return state;
        }

        // Update speech bubble position to follow the fish
        function updateBubblePosition() {
            if (!speakingFish || goatFish.indexOf(speakingFish) === -1) {
                return;
            }

            const fish = speakingFish;
            const bubbleWidth = 300; // max-width from CSS
            const bubbleHeight = 80; // approximate height

            // Calculate position, keeping it on screen
            let x = fish.x - bubbleWidth / 2;
            let y = fish.y - fish.size * 2 - bubbleHeight - 20;

            // Keep it on screen horizontally
            x = Math.max(10, Math.min(x, canvas.width - bubbleWidth - 10));

            // Keep it on screen vertically (if fish is near top, show below instead)
            if (y < 10) {
                y = fish.y + fish.size * 2 + 20;
                commentaryDiv.classList.add('pointer-up');
            } else {
                commentaryDiv.classList.remove('pointer-up');
            }

            commentaryDiv.style.left = x + 'px';
            commentaryDiv.style.top = y + 'px';
        }

        // Display commentary in the UI as a speech bubble from a random fish
        function displayCommentary(text) {
            if (goatFish.length === 0) return;

            // Clear any existing timeout and hide old bubble
            if (commentaryTimeout) {
                clearTimeout(commentaryTimeout);
                commentaryTimeout = null;
            }
            commentaryDiv.classList.remove('visible');
            speakingFish = null;

            // Small delay to ensure fade-out completes, then show new bubble
            setTimeout(() => {
                // Pick a random fish
                speakingFish = goatFish[Math.floor(Math.random() * goatFish.length)];

                commentaryDiv.textContent = text;
                updateBubblePosition();
                commentaryDiv.classList.add('visible');

                // Hide a few seconds before the next commentary would trigger
                commentaryTimeout = setTimeout(() => {
                    commentaryDiv.classList.remove('visible');
                    speakingFish = null;
                    commentaryTimeout = null;
                }, COMMENTARY_INTERVAL - 3000);
            }, 100);
        }

        // Call Anthropic API for fish commentary
        async function getFishCommentary() {
            const apiKey = getApiKey();
            if (!apiKey) {
                console.log('No API key set. Press K to set your Anthropic API key.');
                displayCommentary('No API key set. Press K to set your Anthropic API key.');
                return;
            }

            console.log('Fetching fish commentary...');

            const state = gatherAquariumState();

            // Randomize what topic/perspective to focus on for variety
            const topics = [
                'existential observation about life in the tank',
                'complaint or sarcastic comment about tank conditions',
                'gossip about another fish\'s behavior',
                'philosophical musing about bubbles or water',
                'dry joke about being a goat-fish hybrid',
                'observation about the sheatfish',
                'comment on swimming patterns or zones',
                'snarky remark about personalities',
                'random anxiety or paranoid thought',
                'boast or humble brag',
                'complaint about the glass walls',
                'observation about someone being lazy or hyperactive',
                'comment on the social dynamics',
                'joke about horns underwater'
            ];

            const tones = [
                'sarcastic and dry',
                'anxious and worried',
                'philosophical and pretentious',
                'grumpy and irritable',
                'deadpan and matter-of-fact',
                'passive-aggressive',
                'melodramatic'
            ];

            const randomTopic = topics[Math.floor(Math.random() * topics.length)];
            const randomTone = tones[Math.floor(Math.random() * tones.length)];

            // Randomly choose which stats to include (not all at once)
            const includePersonalities = Math.random() > 0.5;
            const includeZones = Math.random() > 0.5;
            const includeSocial = Math.random() > 0.5;

            let contextInfo = `You are a goat-fish in an aquarium. There are ${state.goatFishCount} goat-fish and ${state.sheatfishCount} sheatfish here.`;

            if (includePersonalities && Object.keys(state.personalityDistribution).length > 0) {
                const personalityList = Object.entries(state.personalityDistribution)
                    .map(([p, count]) => `${count} ${p}`)
                    .join(', ');
                contextInfo += ` Personalities: ${personalityList}.`;
            }

            if (includeZones) {
                contextInfo += ` ${state.fishInUpperZone} fish up top, ${state.fishInMiddleZone} in middle, ${state.fishInLowerZone} at bottom.`;
            }

            if (includeSocial) {
                contextInfo += ` Most social fish has ${state.mostSocialFish.nearbyFriends} friends nearby. Loneliest has ${state.loneliestFish.nearbyFriends}.`;
            }

            // Sometimes mention interesting facts
            if (Math.random() > 0.6) {
                if (state.totalSpooksAllTime > 10) {
                    contextInfo += ` Total spook count: ${state.totalSpooksAllTime}.`;
                }
                if (state.mostSpookedFish.totalSpooked > 3) {
                    contextInfo += ` Someone's been spooked ${state.mostSpookedFish.totalSpooked} times.`;
                }
            }

            const prompt = `${contextInfo}

Make a ${randomTone} comment about: ${randomTopic}.
Be witty and original. Keep it under 20 words. Don't explain yourself, just make the comment.`;

            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-haiku-4-5-20251001',
                        max_tokens: 100,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error:', response.status, errorText);
                    if (response.status === 401) {
                        displayCommentary('API key invalid. Press K to update.');
                    } else {
                        displayCommentary(`API error: ${response.status}. Check console for details.`);
                    }
                    return;
                }

                const data = await response.json();
                console.log('API response:', data);
                if (data.content && data.content[0] && data.content[0].text) {
                    displayCommentary(data.content[0].text);
                } else {
                    console.error('Unexpected API response format:', data);
                    displayCommentary('Received unexpected response from API.');
                }
            } catch (error) {
                console.error('Failed to get fish commentary:', error);
                displayCommentary(`Error: ${error.message}. Check console for details.`);
            }
        }

        // Prompt for API key
        function promptForApiKey() {
            const key = prompt('Enter your Anthropic API key:\n\n(Get one at https://console.anthropic.com/)');
            if (key && key.trim()) {
                if (saveApiKey(key.trim())) {
                    alert('API key saved! Fish will now comment on their surroundings.');
                    // Immediately trigger a commentary
                    getFishCommentary();
                } else {
                    alert('Failed to save API key. Please try again.');
                }
            }
        }

        // Resize canvas to fill window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            plants = createPlants();
            grass = createGrass();
        }

        // Initial setup happens after plants are defined
        function init() {
            resizeCanvas();
            goatFish = createGoatFish();
            sheatfish = createSheatfish();
            bubbles = createBubbles();
            window.addEventListener('resize', resizeCanvas);

            // Save all state when page is about to unload
            window.addEventListener('beforeunload', () => {
                saveAll();
            });

            // Reset function - clear localStorage and reinitialize
            function resetTank() {
                // Clear commentary bubble and timeout
                if (commentaryTimeout) {
                    clearTimeout(commentaryTimeout);
                    commentaryTimeout = null;
                }
                commentaryDiv.classList.remove('visible');
                speakingFish = null;

                try {
                    localStorage.removeItem('goatFishState');
                    localStorage.removeItem('sheatfishState');
                    localStorage.removeItem('bubbleState');
                    localStorage.removeItem('plantState');
                    localStorage.removeItem('grassState');
                    localStorage.removeItem('animationTime');
                } catch (e) {
                    // Silent fail
                }
                // Reinitialize everything
                goatFish = createGoatFish();
                sheatfish = createSheatfish();
                bubbles = createBubbles();
                plants = createPlants();
                grass = createGrass();
                animationTimeOffset = 0;
            }

            // Fullscreen toggle (press 'f' key)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'f' || e.key === 'F') {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                }

                // Spacebar - scare all the fish!
                if (e.key === ' ') {
                    e.preventDefault();
                    goatFish.forEach(fish => fish.spook());
                }

                // 'X' key - reset tank
                if (e.key === 'x' || e.key === 'X') {
                    e.preventDefault();
                    resetTank();
                }

                // 'K' key - set API key for AI commentary
                if (e.key === 'k' || e.key === 'K') {
                    e.preventDefault();
                    promptForApiKey();
                }

                // 'C' key - trigger commentary immediately (if API key is set)
                if (e.key === 'c' || e.key === 'C') {
                    e.preventDefault();
                    console.log('C key pressed - triggering commentary');
                    getFishCommentary();
                }
            });

            // Click handler for spooked goat-fish and bubble spawning
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let clickedFish = false;
                goatFish.forEach(fish => {
                    if (fish.isClicked(x, y)) {
                        fish.spook();
                        clickedFish = true;
                    }
                });

                // If didn't click a fish, spawn bubbles
                if (!clickedFish) {
                    for (let i = 0; i < 8; i++) {
                        const bubble = new Bubble();
                        bubble.x = x + (Math.random() - 0.5) * 40;
                        bubble.y = y + (Math.random() - 0.5) * 40;
                        bubble.initialRadius = 3 + Math.random() * 6;
                        bubble.radius = bubble.initialRadius;
                        bubble.speed = 0.3 + Math.random() * 0.5;
                        bubble.startY = bubble.y;
                        bubbles.push(bubble);
                    }
                }
            });

            // Menu system for mobile
            const menuButton = document.getElementById('menuButton');
            const menuOverlay = document.getElementById('menuOverlay');
            const closeMenu = document.getElementById('closeMenu');

            function openMenu() {
                menuOverlay.classList.add('visible');
            }

            function closeMenuFn() {
                menuOverlay.classList.remove('visible');
            }

            menuButton.addEventListener('click', (e) => {
                e.preventDefault();
                openMenu();
            });

            closeMenu.addEventListener('click', (e) => {
                e.preventDefault();
                closeMenuFn();
            });

            // Close menu when clicking overlay background
            menuOverlay.addEventListener('click', (e) => {
                if (e.target === menuOverlay) {
                    closeMenuFn();
                }
            });

            // Menu item actions
            document.getElementById('menuScareAll').addEventListener('click', () => {
                goatFish.forEach(fish => fish.spook());
                closeMenuFn();
            });

            document.getElementById('menuFullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
                closeMenuFn();
            });

            document.getElementById('menuCommentary').addEventListener('click', () => {
                getFishCommentary();
                closeMenuFn();
            });

            document.getElementById('menuApiKey').addEventListener('click', () => {
                closeMenuFn();
                // Small delay so menu closes before prompt
                setTimeout(() => {
                    promptForApiKey();
                }, 100);
            });

            document.getElementById('menuReset').addEventListener('click', () => {
                closeMenuFn();
                resetTank();
            });
        }

        class GoatFish {
            constructor(savedState = null) {
                if (savedState) {
                    // Restore from saved state
                    this.x = savedState.x;
                    this.y = savedState.y;

                    // Clamp velocities to normal range in case fish was spooked when saved
                    this.vx = Math.max(-1, Math.min(1, savedState.vx));
                    this.vy = Math.max(-0.5, Math.min(0.5, savedState.vy));

                    this.size = savedState.size;
                    this.angle = savedState.angle;
                    this.bodyColor = savedState.bodyColor;
                    this.finColor = savedState.finColor;
                    this.hornColor = savedState.hornColor;

                    // Restore hidden state
                    this.totalSpooked = savedState.totalSpooked || 0;
                    this.personality = savedState.personality || 'chill';
                    this.socialPreference = savedState.socialPreference || 0.5;
                    this.depthPreference = savedState.depthPreference || 0.5;
                } else {
                    // Create new random fish
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 1;
                    this.size = 20 + Math.random() * 30;
                    this.angle = Math.atan2(this.vy, this.vx);

                    // Random colors for variety
                    const hue = Math.random() * 360;
                    this.bodyColor = `hsl(${hue}, 70%, 60%)`;
                    this.finColor = `hsl(${hue + 30}, 60%, 50%)`;
                    this.hornColor = `hsl(${hue - 30}, 50%, 40%)`;

                    // Hidden state for personality and behavior
                    this.totalSpooked = 0;
                    const personalities = ['anxious', 'chill', 'hyperactive', 'lazy', 'curious', 'grumpy'];
                    this.personality = personalities[Math.floor(Math.random() * personalities.length)];
                    this.socialPreference = Math.random(); // 0 = loner, 1 = social butterfly
                    this.depthPreference = Math.random(); // 0 = surface lover, 1 = deep diver
                }

                this.tailPhase = Math.random() * Math.PI * 2;
                this.finPhase = Math.random() * Math.PI * 2;

                // Goat eye properties
                this.pupilOffsetX = 0;
                this.pupilOffsetY = 0;

                // Spooked state
                this.spooked = false;
                this.spookTime = 0;
                this.spinSpeed = 0;
                this.bleatText = '';
                this.bleatOpacity = 0;

                // Activity tracking
                this.distanceTraveled = 0;
                this.nearbyFishCount = 0;
                this.timeSinceLastSpook = Infinity;
            }

            toJSON() {
                return {
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    vy: this.vy,
                    size: this.size,
                    angle: this.angle,
                    bodyColor: this.bodyColor,
                    finColor: this.finColor,
                    hornColor: this.hornColor,
                    totalSpooked: this.totalSpooked,
                    personality: this.personality,
                    socialPreference: this.socialPreference,
                    depthPreference: this.depthPreference
                };
            }

            spook() {
                this.spooked = true;
                this.spookTime = 100;
                this.spinSpeed = 0.5;
                this.totalSpooked++;
                this.timeSinceLastSpook = 0;

                // Zoom away in random direction at high speed
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * 8;
                this.vy = Math.sin(angle) * 8;

                // Random bleat
                const bleats = ['BAAA!', 'MEHHH!', 'üò±', 'AAAH!', 'NOPE!'];
                this.bleatText = bleats[Math.floor(Math.random() * bleats.length)];
                this.bleatOpacity = 1;
            }

            update() {
                // Track distance traveled
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.distanceTraveled += speed;

                // Track time since last spook
                if (this.timeSinceLastSpook < Infinity) {
                    this.timeSinceLastSpook++;
                }

                // Handle spooked state
                if (this.spooked) {
                    this.spookTime--;
                    this.angle += this.spinSpeed;
                    this.spinSpeed *= 0.95;

                    if (this.spookTime <= 0) {
                        this.spooked = false;
                        // Slow back down to normal speed
                        this.vx *= 0.3;
                        this.vy *= 0.3;
                    }
                }

                // Fade out bleat text
                if (this.bleatOpacity > 0) {
                    this.bleatOpacity -= 0.02;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x < this.size || this.x > canvas.width - this.size) {
                    this.vx *= -1;
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                }
                if (this.y < this.size || this.y > canvas.height - this.size) {
                    this.vy *= -1;
                    this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                }

                // Smooth angle transition (only when not spooked)
                if (!this.spooked) {
                    const targetAngle = Math.atan2(this.vy, this.vx);
                    this.angle += (targetAngle - this.angle) * 0.1;
                }

                // Update animation phases
                this.tailPhase += 0.1;
                this.finPhase += 0.15;
            }

            isClicked(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size * 1.5;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const s = this.size;

                // Tail (animated)
                const tailWag = Math.sin(this.tailPhase) * 0.3;
                ctx.beginPath();
                ctx.moveTo(-s * 0.8, 0);
                ctx.quadraticCurveTo(
                    -s * 1.3,
                    s * 0.5 * tailWag,
                    -s * 1.5,
                    s * 0.3 + s * 0.2 * tailWag
                );
                ctx.quadraticCurveTo(
                    -s * 1.3,
                    0,
                    -s * 1.5,
                    -s * 0.3 - s * 0.2 * tailWag
                );
                ctx.quadraticCurveTo(
                    -s * 1.3,
                    -s * 0.5 * tailWag,
                    -s * 0.8,
                    0
                );
                ctx.fillStyle = this.finColor;
                ctx.fill();

                // Body (goat-like)
                ctx.beginPath();
                ctx.ellipse(0, 0, s * 0.8, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.bodyColor;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Top fin (animated)
                const finWave = Math.sin(this.finPhase) * 0.1;
                ctx.beginPath();
                ctx.moveTo(-s * 0.2, -s * 0.5);
                ctx.lineTo(0, -s * 0.9 - finWave * s);
                ctx.lineTo(s * 0.2, -s * 0.5);
                ctx.closePath();
                ctx.fillStyle = this.finColor;
                ctx.fill();

                // Bottom fin
                ctx.beginPath();
                ctx.moveTo(-s * 0.2, s * 0.5);
                ctx.lineTo(0, s * 0.8 + finWave * s);
                ctx.lineTo(s * 0.2, s * 0.5);
                ctx.closePath();
                ctx.fillStyle = this.finColor;
                ctx.fill();

                // Goat head (more prominent and elongated)
                ctx.beginPath();
                ctx.ellipse(s * 0.6, 0, s * 0.4, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.bodyColor;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Goat snout (longer and more prominent)
                ctx.beginPath();
                ctx.ellipse(s * 0.95, 0, s * 0.25, s * 0.18, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.bodyColor;
                ctx.fill();
                ctx.stroke();

                // Bridge of nose
                ctx.beginPath();
                ctx.ellipse(s * 0.8, 0, s * 0.15, s * 0.2, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.bodyColor;
                ctx.fill();

                // Nostrils (adjusted for longer snout)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(s * 1.05, -s * 0.06, s * 0.04, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(s * 1.05, s * 0.06, s * 0.04, 0, Math.PI * 2);
                ctx.fill();

                // Goat ears (longer and more droopy)
                ctx.fillStyle = this.hornColor;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;

                // Left ear (droopy and elongated)
                ctx.beginPath();
                ctx.moveTo(s * 0.5, -s * 0.3);
                ctx.quadraticCurveTo(s * 0.35, -s * 0.45, s * 0.3, -s * 0.6);
                ctx.quadraticCurveTo(s * 0.38, -s * 0.55, s * 0.48, -s * 0.38);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Right ear (droopy and elongated)
                ctx.beginPath();
                ctx.moveTo(s * 0.5, s * 0.3);
                ctx.quadraticCurveTo(s * 0.35, s * 0.45, s * 0.3, s * 0.6);
                ctx.quadraticCurveTo(s * 0.38, s * 0.55, s * 0.48, s * 0.38);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Goat horns (bigger, more curved and prominent)
                ctx.strokeStyle = this.hornColor;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Left horn (curved back like real goat horns)
                ctx.beginPath();
                ctx.moveTo(s * 0.52, -s * 0.32);
                ctx.quadraticCurveTo(s * 0.45, -s * 0.7, s * 0.25, -s * 0.95);
                ctx.quadraticCurveTo(s * 0.15, -s * 1.0, s * 0.05, -s * 0.95);
                ctx.stroke();

                // Horn ridges for texture (left)
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4;
                for (let i = 0; i < 4; i++) {
                    const t = i / 4;
                    ctx.beginPath();
                    ctx.arc(s * (0.52 - t * 0.47), -s * (0.32 + t * 0.63), s * 0.05, 0, Math.PI);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Right horn (curved back like real goat horns)
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(s * 0.52, s * 0.32);
                ctx.quadraticCurveTo(s * 0.45, s * 0.7, s * 0.25, s * 0.95);
                ctx.quadraticCurveTo(s * 0.15, s * 1.0, s * 0.05, s * 0.95);
                ctx.stroke();

                // Horn ridges for texture (right)
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4;
                for (let i = 0; i < 4; i++) {
                    const t = i / 4;
                    ctx.beginPath();
                    ctx.arc(s * (0.52 - t * 0.47), s * (0.32 + t * 0.63), s * 0.05, Math.PI, 2 * Math.PI);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Goat-like rectangular pupil eyes (adjusted for new head)
                // Eye whites
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(s * 0.7, -s * 0.15, s * 0.13, s * 0.13, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(s * 0.7, s * 0.15, s * 0.13, s * 0.13, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Rectangular pupils (goat-like, horizontal)
                ctx.fillStyle = 'black';
                ctx.fillRect(s * 0.64, -s * 0.17, s * 0.13, s * 0.04);
                ctx.fillRect(s * 0.64, s * 0.13, s * 0.13, s * 0.04);

                // Goat beard (bushier and more prominent)
                ctx.strokeStyle = this.hornColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                // Multiple beard strands for bushier look
                const beardStrands = [
                    [s * 0.9, s * 0.15, s * 1.1, s * 0.25],
                    [s * 0.92, s * 0.12, s * 1.12, s * 0.2],
                    [s * 0.88, s * 0.18, s * 1.08, s * 0.3],
                    [s * 0.9, s * 0.08, s * 1.1, s * 0.1],
                    [s * 0.92, s * 0.05, s * 1.12, s * 0.05],
                    [s * 0.9, s * 0.02, s * 1.1, -s * 0.02],
                ];

                beardStrands.forEach(([x1, y1, x2, y2]) => {
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                });

                ctx.restore();

                // Draw bleat text above fish
                if (this.bleatOpacity > 0) {
                    ctx.save();
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.bleatOpacity})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${this.bleatOpacity})`;
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.bleatText, this.x, this.y - s * 1.5);
                    ctx.fillText(this.bleatText, this.x, this.y - s * 1.5);
                    ctx.restore();
                }
            }
        }

        // Bubbles
        class Bubble {
            constructor(savedState = null) {
                if (savedState) {
                    this.x = savedState.x;
                    this.y = savedState.y;
                    this.radius = savedState.radius;
                    this.initialRadius = savedState.initialRadius || savedState.radius;
                    // Clamp speed to new slower range
                    this.speed = Math.min(0.8, Math.max(0.3, savedState.speed * 0.4));
                    this.wobble = savedState.wobble;
                    this.wobbleSpeed = savedState.wobbleSpeed || 0.05;
                    this.wobbleAmplitude = savedState.wobbleAmplitude || 0.5;
                } else {
                    this.x = Math.random() * canvas.width;
                    // Start at random height throughout the tank for better distribution
                    this.y = Math.random() * canvas.height;
                    this.initialRadius = 2 + Math.random() * 4;
                    this.radius = this.initialRadius;
                    // Wider speed variation - smaller bubbles tend to be slower
                    this.speed = 0.2 + Math.random() * 1.0;
                    this.wobble = Math.random() * Math.PI * 2;
                    this.wobbleSpeed = 0.03 + Math.random() * 0.04;
                    this.wobbleAmplitude = 0.3 + Math.random() * 0.5;
                }

                // Always use bottom as reference for expansion, regardless of spawn height
                this.startY = canvas.height;

                // Calculate current radius based on distance from bottom
                const distanceTraveled = this.startY - this.y;
                const maxDistance = canvas.height;
                const expansionFactor = 1 + (distanceTraveled / maxDistance) * 0.5;
                this.radius = this.initialRadius * expansionFactor;
            }

            toJSON() {
                return {
                    x: this.x,
                    y: this.y,
                    radius: this.radius,
                    initialRadius: this.initialRadius,
                    speed: this.speed,
                    wobble: this.wobble,
                    wobbleSpeed: this.wobbleSpeed,
                    wobbleAmplitude: this.wobbleAmplitude
                };
            }

            update() {
                // Bubbles accelerate slightly as they rise (buoyancy)
                // Vary acceleration based on bubble size
                const acceleration = 0.003 + (this.initialRadius / 6) * 0.004;
                this.speed += acceleration;
                this.speed = Math.min(this.speed, 1.5 + this.initialRadius * 0.2);

                this.y -= this.speed;

                // More natural wobble with varying amplitude
                this.wobble += this.wobbleSpeed;
                const wobbleOffset = Math.sin(this.wobble) * this.wobbleAmplitude;
                this.x += wobbleOffset;

                // Add some random drift
                this.x += (Math.random() - 0.5) * 0.1;

                // Bubbles expand as they rise (pressure decrease)
                const distanceTraveled = this.startY - this.y;
                const maxDistance = canvas.height;
                const expansionFactor = 1 + (distanceTraveled / maxDistance) * 0.5;
                this.radius = this.initialRadius * expansionFactor;

                // Pop at surface or reset if too far off screen
                if (this.y < -20 || this.x < -50 || this.x > canvas.width + 50) {
                    this.y = canvas.height + 20;
                    this.x = Math.random() * canvas.width;
                    this.startY = this.y;
                    this.speed = 0.2 + Math.random() * 1.0;
                    this.radius = this.initialRadius;
                }
            }

            draw() {
                // Slight shimmer effect on bubbles
                const shimmer = Math.sin(this.wobble * 2) * 0.1 + 0.9;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * shimmer})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 * shimmer})`;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Add highlight to make bubble look more spherical
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.4 * shimmer})`;
                ctx.fill();
            }
        }

        // Sheatfish (catfish that sucks along the bottom)
        class Sheatfish {
            constructor(savedState = null) {
                if (savedState) {
                    this.x = savedState.x;
                    this.y = savedState.y;
                    this.vx = savedState.vx;
                    this.size = savedState.size;
                    this.color = savedState.color;
                    this.whiskerColor = savedState.whiskerColor;
                } else {
                    // Start at random position
                    this.x = Math.random() * canvas.width;
                    // Stay near bottom
                    this.y = canvas.height - 50 - Math.random() * 30;
                    // Slow horizontal movement
                    this.vx = (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.4);
                    this.size = 30 + Math.random() * 20;

                    // Muddy catfish colors
                    const hue = 30 + Math.random() * 30; // Browns/tans
                    this.color = `hsl(${hue}, 40%, 35%)`;
                    this.whiskerColor = `hsl(${hue}, 30%, 25%)`;
                }

                this.suckPhase = Math.random() * Math.PI * 2;
                this.whiskerPhase = Math.random() * Math.PI * 2;
                this.angle = this.vx > 0 ? 0 : Math.PI;
            }

            toJSON() {
                return {
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    size: this.size,
                    color: this.color,
                    whiskerColor: this.whiskerColor
                };
            }

            update() {
                this.x += this.vx;

                // Gentle vertical wobble (bottom feeder behavior)
                this.y += Math.sin(this.suckPhase) * 0.2;

                // Keep near bottom
                const minY = canvas.height - 80;
                const maxY = canvas.height - 30;
                this.y = Math.max(minY, Math.min(maxY, this.y));

                // Wrap around screen edges (can go off-screen)
                if (this.vx > 0 && this.x > canvas.width + this.size * 2) {
                    this.x = -this.size * 2;
                } else if (this.vx < 0 && this.x < -this.size * 2) {
                    this.x = canvas.width + this.size * 2;
                }

                // Update angle smoothly based on direction
                const targetAngle = this.vx > 0 ? 0 : Math.PI;
                this.angle += (targetAngle - this.angle) * 0.05;

                // Update animation phases
                this.suckPhase += 0.03;
                this.whiskerPhase += 0.08;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const s = this.size;

                // Tail
                ctx.beginPath();
                ctx.moveTo(-s * 0.9, 0);
                ctx.quadraticCurveTo(-s * 1.2, -s * 0.2, -s * 1.4, -s * 0.3);
                ctx.quadraticCurveTo(-s * 1.2, 0, -s * 1.4, s * 0.3);
                ctx.quadraticCurveTo(-s * 1.2, s * 0.2, -s * 0.9, 0);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Main body (long and low for bottom feeder)
                ctx.beginPath();
                ctx.ellipse(0, 0, s * 0.9, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Belly (lighter, for bottom feeder look)
                ctx.beginPath();
                ctx.ellipse(0, s * 0.15, s * 0.7, s * 0.25, 0, 0, Math.PI * 2);
                const lighterColor = this.color.replace(/\d+%\)$/, (match) => {
                    const lightness = parseInt(match);
                    return (lightness + 15) + '%)';
                });
                ctx.fillStyle = lighterColor;
                ctx.fill();

                // Top fin
                ctx.beginPath();
                ctx.moveTo(-s * 0.3, -s * 0.35);
                ctx.lineTo(-s * 0.2, -s * 0.6);
                ctx.lineTo(0, -s * 0.35);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();

                // Side fins (pectoral fins)
                ctx.beginPath();
                ctx.ellipse(-s * 0.2, s * 0.35, s * 0.3, s * 0.15, -0.3, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-s * 0.2, -s * 0.35, s * 0.3, s * 0.15, 0.3, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.ellipse(s * 0.6, 0, s * 0.4, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Sucker mouth (bottom feeder) with sucking animation
                const suckAmount = Math.sin(this.suckPhase) * 0.05 + 0.1;
                ctx.beginPath();
                ctx.ellipse(s * 0.9, s * 0.2, s * 0.15, s * (0.1 + suckAmount), 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Eyes (small, on top of head)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(s * 0.5, -s * 0.2, s * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(s * 0.5, s * 0.2, s * 0.06, 0, Math.PI * 2);
                ctx.fill();

                // Whiskers (barbels) - animated
                ctx.strokeStyle = this.whiskerColor;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                const whiskerWave = Math.sin(this.whiskerPhase) * 0.1;

                // Upper whiskers
                ctx.beginPath();
                ctx.moveTo(s * 0.85, -s * 0.1);
                ctx.quadraticCurveTo(s * 1.1, -s * 0.2 + whiskerWave * s, s * 1.3, -s * 0.15 + whiskerWave * s);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(s * 0.85, s * 0.1);
                ctx.quadraticCurveTo(s * 1.1, s * 0.2 - whiskerWave * s, s * 1.3, s * 0.15 - whiskerWave * s);
                ctx.stroke();

                // Lower whiskers (longer)
                ctx.beginPath();
                ctx.moveTo(s * 0.9, -s * 0.25);
                ctx.quadraticCurveTo(s * 1.2, -s * 0.4 + whiskerWave * s * 0.5, s * 1.5, -s * 0.35 + whiskerWave * s);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(s * 0.9, s * 0.25);
                ctx.quadraticCurveTo(s * 1.2, s * 0.4 - whiskerWave * s * 0.5, s * 1.5, s * 0.35 - whiskerWave * s);
                ctx.stroke();

                ctx.restore();
            }
        }

        // Seaweed/plants
        class Plant {
            constructor(xOrSavedState = null) {
                if (xOrSavedState && typeof xOrSavedState === 'object') {
                    // Restore from saved state
                    this.x = xOrSavedState.x;
                    this.segments = xOrSavedState.segments;
                    this.segmentHeight = xOrSavedState.segmentHeight;
                    this.color = xOrSavedState.color;
                    this.phase = xOrSavedState.phase;
                } else {
                    // Create new plant with optional x position
                    this.x = xOrSavedState || Math.random() * canvas.width;
                    this.segments = 8 + Math.floor(Math.random() * 5);
                    this.segmentHeight = 30 + Math.random() * 20;
                    this.color = `hsl(${100 + Math.random() * 40}, 50%, 35%)`;
                    this.phase = Math.random() * Math.PI * 2;
                }
            }

            toJSON() {
                return {
                    x: this.x,
                    segments: this.segments,
                    segmentHeight: this.segmentHeight,
                    color: this.color,
                    phase: this.phase
                };
            }

            draw(time) {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(this.x, canvas.height);

                for (let i = 0; i < this.segments; i++) {
                    const y = canvas.height - i * this.segmentHeight;
                    const sway = Math.sin(time * 0.001 + this.phase + i * 0.3) * (i * 3);
                    ctx.lineTo(this.x + sway, y);
                }

                ctx.stroke();
            }
        }

        function createPlants() {
            const plants = [];

            // Try to load saved plant state from localStorage
            try {
                const savedPlants = localStorage.getItem('plantState');
                if (savedPlants) {
                    const plantData = JSON.parse(savedPlants);
                    for (let i = 0; i < plantData.length; i++) {
                        plants.push(new Plant(plantData[i]));
                    }
                    return plants;
                }
            } catch (e) {
                // Silent fail, just create new plants
            }

            // Create new plants if no saved state
            const plantCount = Math.max(12, Math.floor(canvas.width / 100));
            for (let i = 0; i < plantCount; i++) {
                const spacing = canvas.width / plantCount;
                plants.push(new Plant(spacing * i + spacing / 2 + (Math.random() - 0.5) * 40));
            }
            return plants;
        }

        // Grass blades
        class Grass {
            constructor(xOrSavedState = null) {
                if (xOrSavedState && typeof xOrSavedState === 'object') {
                    this.x = xOrSavedState.x;
                    this.height = xOrSavedState.height;
                    this.color = xOrSavedState.color;
                    this.phase = xOrSavedState.phase;
                } else {
                    this.x = xOrSavedState || Math.random() * canvas.width;
                    this.height = 10 + Math.random() * 25;
                    this.color = `hsl(${110 + Math.random() * 30}, 60%, ${25 + Math.random() * 15}%)`;
                    this.phase = Math.random() * Math.PI * 2;
                }
            }

            toJSON() {
                return {
                    x: this.x,
                    height: this.height,
                    color: this.color,
                    phase: this.phase
                };
            }

            draw(time) {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                const sway = Math.sin(time * 0.002 + this.phase) * 3;

                ctx.beginPath();
                ctx.moveTo(this.x, canvas.height);
                ctx.lineTo(this.x + sway, canvas.height - this.height);
                ctx.stroke();
            }
        }

        function createGrass() {
            const grass = [];

            // Try to load saved grass state from localStorage
            try {
                const savedGrass = localStorage.getItem('grassState');
                if (savedGrass) {
                    const grassData = JSON.parse(savedGrass);
                    for (let i = 0; i < grassData.length; i++) {
                        grass.push(new Grass(grassData[i]));
                    }
                    return grass;
                }
            } catch (e) {
                // Silent fail, just create new grass
            }

            // Create new grass if no saved state - dense coverage
            const grassCount = Math.max(50, Math.floor(canvas.width / 15));
            for (let i = 0; i < grassCount; i++) {
                grass.push(new Grass(Math.random() * canvas.width));
            }
            return grass;
        }

        function createGoatFish() {
            const fish = [];

            // Try to load saved fish state from localStorage
            try {
                const savedFish = localStorage.getItem('goatFishState');
                if (savedFish) {
                    const fishData = JSON.parse(savedFish);
                    for (let i = 0; i < fishData.length; i++) {
                        fish.push(new GoatFish(fishData[i]));
                    }
                    return fish;
                }
            } catch (e) {
                // Silent fail, just create new fish
            }

            // Create new random fish if no saved state
            // Scale fish count based on viewport area (1 fish per ~100,000 pixels)
            // Mobile devices get fewer fish based on smaller screen size
            const area = canvas.width * canvas.height;
            const isMobile = canvas.width < 768; // Simple mobile detection
            const minFish = isMobile ? 6 : 15;
            const maxFish = isMobile ? 12 : 25;
            const fishCount = Math.max(minFish, Math.min(maxFish, Math.floor(area / 100000)));
            for (let i = 0; i < fishCount; i++) {
                fish.push(new GoatFish());
            }
            return fish;
        }

        function createSheatfish() {
            const sheatfish = [];

            // Try to load saved sheatfish state from localStorage
            try {
                const savedSheatfish = localStorage.getItem('sheatfishState');
                if (savedSheatfish) {
                    const sheatfishData = JSON.parse(savedSheatfish);
                    for (let i = 0; i < sheatfishData.length; i++) {
                        sheatfish.push(new Sheatfish(sheatfishData[i]));
                    }
                    return sheatfish;
                }
            } catch (e) {
                // Silent fail, just create new sheatfish
            }

            // Create 2-3 sheatfish (they're bottom feeders, less common)
            const sheatfishCount = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < sheatfishCount; i++) {
                sheatfish.push(new Sheatfish());
            }
            return sheatfish;
        }

        function saveAll() {
            try {
                const fishData = goatFish.map(fish => fish.toJSON());
                const sheatfishData = sheatfish.map(fish => fish.toJSON());
                const bubbleData = bubbles.map(bubble => bubble.toJSON());
                const plantData = plants.map(plant => plant.toJSON());
                const grassData = grass.map(g => g.toJSON());

                localStorage.setItem('goatFishState', JSON.stringify(fishData));
                localStorage.setItem('sheatfishState', JSON.stringify(sheatfishData));
                localStorage.setItem('bubbleState', JSON.stringify(bubbleData));
                localStorage.setItem('plantState', JSON.stringify(plantData));
                localStorage.setItem('grassState', JSON.stringify(grassData));
                localStorage.setItem('animationTime', currentAnimationTime.toString());
            } catch (e) {
                // Silent fail
            }
        }

        function createBubbles() {
            const bubbles = [];

            // Try to load saved bubble state from localStorage
            try {
                const savedBubbles = localStorage.getItem('bubbleState');
                if (savedBubbles) {
                    const bubbleData = JSON.parse(savedBubbles);
                    // Restore all saved bubbles (including clicked ones)
                    for (let i = 0; i < bubbleData.length; i++) {
                        bubbles.push(new Bubble(bubbleData[i]));
                    }
                    return bubbles;
                }
            } catch (e) {
                // Silent fail, just create new bubbles
            }

            // Create new bubbles if no saved state
            // Scale bubble count based on viewport area
            const area = canvas.width * canvas.height;
            const desiredBubbleCount = Math.max(8, Math.floor(area / 100000));
            for (let i = 0; i < desiredBubbleCount; i++) {
                bubbles.push(new Bubble());
            }
            return bubbles;
        }

        let plants = [];
        let grass = [];
        let goatFish = [];
        let sheatfish = [];
        let bubbles = [];

        // Track animation time offset to preserve animation state across reloads
        let animationTimeOffset = 0;
        let currentAnimationTime = 0;
        try {
            const saved = localStorage.getItem('animationTime');
            if (saved) {
                animationTimeOffset = parseFloat(saved);
            }
        } catch (e) {
            // Silent fail
        }

        // Animation loop
        function animate(timestamp) {
            // Water gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a5f7a');    // Lighter blue at top
            gradient.addColorStop(0.5, '#0e4d66');  // Mid tone
            gradient.addColorStop(1, '#083344');    // Darker at bottom
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Adjust timestamp with saved offset
            currentAnimationTime = timestamp + animationTimeOffset;

            // Trigger AI commentary periodically (if API key is set and no commentary is currently showing)
            if (getApiKey() && timestamp - lastCommentaryTime > COMMENTARY_INTERVAL && !commentaryTimeout) {
                lastCommentaryTime = timestamp;
                getFishCommentary();
            }

            // Draw grass (behind plants)
            grass.forEach(g => g.draw(currentAnimationTime));

            // Draw plants
            plants.forEach(plant => plant.draw(currentAnimationTime));

            // Update and draw bubbles
            bubbles.forEach(bubble => {
                bubble.update();
                bubble.draw();
            });

            // Update and draw sheatfish (bottom feeders, drawn before goat-fish)
            sheatfish.forEach(fish => {
                fish.update();
                fish.draw();
            });

            // Update and draw goat-fish
            goatFish.forEach(fish => {
                fish.update();
                fish.draw();
            });

            // Update speech bubble position if a fish is speaking
            if (speakingFish) {
                updateBubblePosition();
            }

            requestAnimationFrame(animate);
        }

        // Initialize and start animation
        init();
        animate(0);
    </script>
</body>
</html>